###########Recherche###############
db.posts.find().limit(10)
db.posts.find({ "author": "machine" })
db.listingsAndReviews.find({
  "address.market": "Rio De Janeiro",
  "accommodates": { "$gte": 4 }
})

db.listingsAndReviews.find({
  "price": { "$lt": 100 },
  "review_scores.review_scores_cleanliness": 10
})
##############Mise √† jour##############
db.posts.insertOne({
  "title": "MBSE: Theoretical Foundations",
  "author": "Ali Koudri",
  "body": "Introduction au MBSE",
  "tags": ["engineering", "system", "complex"],
  "comments": []
})

db.posts.updateOne(
  { "title": "US Constitution" },
  { "$push": { "tags": "law" } }
)

db.posts.updateMany(
  { "title": "US Constitution" },
  { "$addToSet": { "tags": "law" } }
)

db.sales.updateOne(
  {
    "_id": ObjectId("5bd761dcae323e45a93ccfe8"),
    "items.name": "pens"
  },
  { "$set": { "items.$.quantity": 10 } }
)

db.posts.updateOne(
  { "title": "Gettysburg Address" },
  { "$pullAll": { "tags": ["civil", "war"] } }
)

########################BULKS#############

db.sales.bulkWrite([
  // 1. insertOne : Nouvelle vente √† New York
  {
    "insertOne": {
      "document": {
        "saleDate": new Date(),
        "items": [
          { "name": "laptop", "tags": ["electronics", "school", "office"], "price": NumberDecimal("899.99"), "quantity": 1 },
          { "name": "backpack", "tags": ["school", "travel"], "price": NumberDecimal("45.50"), "quantity": 1 }
        ],
        "storeLocation": "New York",
        "customer": { "gender": "M", "age": 34, "email": "new.customer@example.com", "satisfaction": 4 },
        "couponUsed": false,
        "purchaseMethod": "Online"
      }
    }
  },

  // 2. updateOne : Mettre √† jour la satisfaction client
  {
    "updateOne": {
      "filter": { "_id": ObjectId("5bd761dcae323e45a93ccfe8") },
      "update": { "$set": { "customer.satisfaction": 5 } }
    }
  },

  // 3. updateMany : Ajouter un champ d'audit pour Denver
  {
    "updateMany": {
      "filter": { "storeLocation": "Denver" },
      "update": { "$set": { "audit_required": true } }
    }
  },

  // 4. deleteMany : Supprimer les ventes par t√©l√©phone
  {
    "deleteMany": {
      "filter": { "purchaseMethod": "Phone" }
    }
  },

  // 5. replaceOne : Remplacer un document erron√©
  {
    "replaceOne": {
      "filter": { "_id": ObjectId("5bd761dcae323e45a93ccff0") },
      "replacement": {
        "saleDate": ISODate("2016-12-01T12:00:00Z"), // Date corrig√©e
        "items": [
          { "name": "envelopes", "tags": ["stationery", "office"], "price": NumberDecimal("10.99"), "quantity": 1 }
        ],
        "storeLocation": "San Diego", // Lieu corrig√©
        "customer": { "gender": "F", "age": 29, "email": "fixed.customer@example.com", "satisfaction": 5 },
        "couponUsed": false,
        "purchaseMethod": "In store"
      }
    }
  }
])

#####################DELETION######################

db.posts.updateMany(
  { }, // Filtre vide pour cibler tous les documents
  { "$pull": { "comments": { "author": "Elizabet Kleine" } } }
)

db.sales.updateMany(
  { "storeLocation": "Denver" },
  { "$pull": { "items": { "name": "notepad" } } }
)

db.listingsAndReviews.updateOne(
  { "_id": "1003530" },
  { "$unset": { "neighborhood_overview": "" } }
)

db.listingsAndReviews.deleteMany({
  "address.country": "Brazil",
  "price": { "$gt": 500 }
})

####################TRANSACTIONS################
use analytics

// Ajoute une balance de 5000 au compte source
db.accounts.updateOne(
  { "account_id": 137994 },
  { "$set": { "balance": 5000 } }
)

// Ajoute une balance de 5000 au compte de destination
db.accounts.updateOne(
  { "account_id": 977982 },
  { "$set": { "balance": 5000 } }
)

// --- D√âBUT DU SCRIPT DE TRANSACTION ---

// 1. D√©marrer une session
const session = db.getMongo().startSession();

// 2. D√©marrer la transaction
session.startTransaction();

try {
  // 3. R√©cup√©rer les collections √† travers la session
  const accountsCollection = session.getDatabase("analytics").accounts;

  // 4. D√©biter le compte source (avec v√©rification du solde)
  const debitResult = accountsCollection.updateOne(
    { "account_id": 137994, "balance": { "$gte": 500 } }, // Filtre : v√©rifie que le solde est suffisant
    { "$inc": { "balance": -500 } }
  );

  // Si aucun document n'a √©t√© modifi√©, le solde √©tait insuffisant. On l√®ve une erreur.
  if (debitResult.modifiedCount === 0) {
    throw new Error("Solde insuffisant sur le compte source ou compte inexistant.");
  }

  // 5. Cr√©diter le compte de destination
  accountsCollection.updateOne(
    { "account_id": 977982 },
    { "$inc": { "balance": 500 } }
  );

  // 6. Valider la transaction si tout s'est bien pass√©
  session.commitTransaction();
  print("‚úÖ Transaction valid√©e avec succ√®s !");

} catch (error) {
  // 7. Annuler la transaction en cas d'erreur
  session.abortTransaction();
  print("‚ùå Erreur durant la transaction. Op√©rations annul√©es.");
  print("Raison : " + error);

} finally {
  // 8. Terminer la session pour lib√©rer les ressources
  session.endSession();
  print("üîö Session termin√©e.");
}

// --- FIN DU SCRIPT DE TRANSACTION ---

db.accounts.find(
  { "account_id": { "$in": [137994, 977982] } },
  { "account_id": 1, "balance": 1, "_id": 0 }
)

######################AGGS##################

db.sales.aggregate([
  {
    "$group": {
      "_id": "$storeLocation",
      "nombreDeVentes": { "$sum": 1 }
    }
  },
  {
    "$sort": { "nombreDeVentes": -1 }
  }
])

db.sales.aggregate([
  {
    "$group": {
      "_id": null, // Regroupe tous les documents ensemble
      "ageMoyen": { "$avg": "$customer.age" }
    }
  }
])

db.sales.aggregate([
  {
    "$unwind": "$items"
  },
  {
    "$group": {
      "_id": "$storeLocation",
      "chiffreAffairesTotal": {
        "$sum": { "$multiply": ["$items.price", "$items.quantity"] }
      }
    }
  },
  {
    "$sort": { "chiffreAffairesTotal": -1 }
  }
])

db.sales.aggregate([
  {
    "$group": {
      "_id": "$customer.satisfaction",
      "nombreDeVentes": { "$sum": 1 }
    }
  },
  {
    "$sort": { "_id": 1 } // Trie par niveau de satisfaction (1, 2, 3...)
  }
])

db.sales.aggregate([
  {
    "$match": { "purchaseMethod": "In store" }
  },
  {
    "$unwind": "$items"
  },
  {
    "$group": {
      "_id": "$storeLocation",
      "nbVentesEnMagasin": {
        "$sum": "$items.quantity"
      }
    }
  },
  {
    "$sort": { "nbVentesEnMagasin": -1 }
  }
])

// Sur la base 'analytics', collection 'accounts'
db.accounts.aggregate([
  { "$unwind": "$products" },
  { "$sortByCount": "$products" }
])

// Sur la base 'analytics', collection 'transactions'
db.transactions.aggregate([
  { "$unwind": "$transactions" },
  { "$match": { "transactions.transaction_code": "buy" } },
  {
    "$group": {
      "_id": "$account_id",
      "montantTotalAchat": {
        "$sum": { "$toDouble": "$transactions.total" }
      }
    }
  }
])

// Sur la base 'airbnb', collection 'listingsAndReviews'
db.listingsAndReviews.aggregate([
  { "$group": { "_id": "$address.country", "nombreDeLogements": { "$sum": 1 } } },
  { "$sort": { "nombreDeLogements": -1 } },
  { "$limit": 5 }
])

// Sur la base 'mflix', collection 'comments'
db.comments.aggregate([
  {
    "$lookup": {
      "from": "users",
      "localField": "email",
      "foreignField": "email",
      "as": "detailsUtilisateur"
    }
  },
  { "$limit": 5 } // Ajout√© pour ne pas afficher des milliers de r√©sultats
])

// Sur la base 'airbnb', collection 'listingsAndReviews'
db.listingsAndReviews.aggregate([
  { "$match": { "number_of_reviews": { "$gt": 50 } } },
  {
    "$group": {
      "_id": "$property_type",
      "scoreMoyen": { "$avg": "$review_scores.review_scores_rating" }
    }
  },
  { "$sort": { "scoreMoyen": -1 } }
])

###############################

db.posts.mapReduce(
  function() { // map
    if (this.tags) {
      this.tags.forEach(tag => {
        emit(tag, 1);
      });
    }
  },
  function(key, values) { // reduce
    return Array.sum(values);
  },
  {
    out: "tag_counts" // Sortie dans une nouvelle collection
  }
)

// Pour voir le r√©sultat :
db.tag_counts.find().sort({ "value": -1 })

VS

db.posts.aggregate([
  { "$unwind": "$tags" },
  { "$sortByCount": "$tags" }
])

db.sales.mapReduce(
  function() { // map
    this.items.forEach(item => {
      emit(item.name, item.quantity);
    });
  },
  function(key, values) { // reduce
    return Array.sum(values);
  },
  {
    out: "product_quantities"
  }
)

// Pour voir le r√©sultat :
db.product_quantities.find().sort({ "value": -1 })

VS

db.sales.aggregate([
  { "$unwind": "$items" },
  {
    "$group": {
      "_id": "$items.name", // On regroupe par le nom du produit
      "quantiteTotale": { "$sum": "$items.quantity" }
    }
  },
  { "$sort": { "quantiteTotale": -1 } }
])

// Sur la base 'airbnb', collection 'listingsAndReviews'
db.listingsAndReviews.aggregate([
  {
    "$group": {
      "_id": "$property_type",
      "prixMoyen": { "$avg": "$price" }
    }
  },
  {
    "$sort": { "prixMoyen": -1 }
  }
])

##################VALIDATION###################

// Assurez-vous d'√™tre sur la bonne base de donn√©es
use supplies

db.createCollection("validated_sales", {
  validator: {
    "$jsonSchema": {
      "bsonType": "object",
      "required": ["saleDate", "items", "storeLocation", "customer", "couponUsed", "purchaseMethod"],
      "properties": {
        "saleDate": {
          "bsonType": "date",
          "description": "doit √™tre de type date et est obligatoire."
        },
        "storeLocation": {
          "bsonType": "string",
          "description": "doit √™tre une cha√Æne de caract√®res et est obligatoire."
        },
        "couponUsed": {
          "bsonType": "bool",
          "description": "doit √™tre un bool√©en et est obligatoire."
        },
        "purchaseMethod": {
          "enum": ["Online", "In store"],
          "description": "doit √™tre 'Online' ou 'In store' et est obligatoire."
        },
        "customer": {
          "bsonType": "object",
          "required": ["gender", "age", "email", "satisfaction"],
          "properties": {
            "gender": {
              "bsonType": "string"
            },
            "age": {
              "bsonType": "int",
              "minimum": 17, // Sup√©rieur √† 16
              "description": "doit √™tre un entier sup√©rieur √† 16."
            },
            "email": {
              "bsonType": "string",
              "pattern": "^.+@.+\\..+$", // Format email simple
              "description": "doit √™tre une adresse email valide et est obligatoire."
            },
            "satisfaction": {
              "bsonType": "int",
              "minimum": 1,
              "maximum": 5,
              "description": "doit √™tre un entier entre 1 et 5."
            }
          }
        },
        "items": {
          "bsonType": "array",
          "minItems": 1, // Le tableau ne doit pas √™tre vide
          "items": {
            "bsonType": "object",
            "required": ["name", "tags", "price", "quantity"],
            "properties": {
              "name": { "bsonType": "string" },
              "tags": { "bsonType": "array", "items": { "bsonType": "string" } },
              "price": { "bsonType": "decimal" },
              "quantity": { "bsonType": "int", "minimum": 1 } // Sup√©rieur √† 0
            }
          }
        }
      }
    }
  }
})

db.validated_sales.insertOne({
  "saleDate": new Date(),
  "items": [
    { "name": "laptop", "tags": ["electronics"], "price": NumberDecimal("1200.00"), "quantity": 1 }
  ],
  "storeLocation": "New York",
  "customer": { "gender": "F", "age": 30, "email": "test@example.com", "satisfaction": 5 },
  "couponUsed": false,
  "purchaseMethod": "Online"
})

db.validated_sales.insertOne({
  "saleDate": new Date(),
  "items": [{"name": "mouse", "tags": ["office"], "price": NumberDecimal("25.00"), "quantity": 1}],
  "storeLocation": "Denver",
  "couponUsed": true,
  "purchaseMethod": "In store"
})
// Erreur attendue : Document failed validation (champ 'customer' requis)

db.validated_sales.insertOne({
  "saleDate": new Date(),
  "items": [{"name": "keyboard", "tags": ["office", "gaming"], "price": NumberDecimal("75.00"), "quantity": 1}],
  "storeLocation": "Seattle",
  "customer": { "gender": "M", "age": 15, "email": "minor@example.com", "satisfaction": 4 },
  "couponUsed": false,
  "purchaseMethod": "Online"
})
// Erreur attendue : Document failed validation (√¢ge minimum non respect√©)

db.validated_sales.insertOne({
  "saleDate": new Date(),
  "items": [], // Tableau vide, ce qui est interdit par minItems: 1
  "storeLocation": "London",
  "customer": { "gender": "M", "age": 55, "email": "shopper@example.co.uk", "satisfaction": 5 },
  "couponUsed": false,
  "purchaseMethod": "Online"
})
// Erreur attendue : Document failed validation (le tableau 'items' est trop court)

db.validated_sales.insertOne({
  "saleDate": new Date(),
  "items": [{"name": "webcam", "tags": ["office"], "price": NumberDecimal("80.00"), "quantity": 1}],
  "storeLocation": "Austin",
  "customer": { "gender": "F", "age": 42, "email": "another@example.com", "satisfaction": 3 },
  "couponUsed": true,
  "purchaseMethod": "Phone" // Valeur non autoris√©e
})
// Erreur attendue : Document failed validation (valeur non pr√©sente dans l'enum)

##################GEO########################

// Sur la base 'geospatial'
use geospatial

db.shipwrecks.createIndex({ "coordinates": "2dsphere" })

db.shipwrecks.find({
  "coordinates": {
    "$near": {
      "$geometry": {
        "type": "Point",
        "coordinates": [-74.0, 18.5]
      }
    }
  }
}).limit(5)

db.shipwrecks.find({
  "feature_type": "Wrecks - Visible",
  "coordinates": {
    "$geoIntersects": {
      "$geometry": {
        "type": "Polygon",
        "coordinates": [
          [ // D√©but du polygone
            [-75.0, 18.0],
            [-73.0, 18.0],
            [-74.0, 19.0],
            [-75.0, 18.0] // Fermeture du polygone
          ]
        ]
      }
    }
  }
})

db.listingAndReviews.createIndex({ "address.location": "2dsphere" })

const KILOMETERS_TO_RADIANS = 1 / 6378.1;

db.listingsAndReviews.find({
  "address.location": {
    "$geoWithin": {
      "$centerSphere": [
        [-73.9857, 40.7580], // Coordonn√©es de Times Square
        2 * KILOMETERS_TO_RADIANS // Rayon de 2 km converti en radians
      ]
    }
  }
})

############INDEX#############

db.listingsAndReviews.explain("executionStats").find({
  "address.country": "Spain"
}).sort({
  "price": 1
})

db.listingsAndReviews.createIndex({
  "address.country": 1,
  "price": 1
})

db.movies.createIndex({
  "title": 1,
  "year": 1
})

db.movies.find(
  { "year": { "$gt": 2010 } },
  { "_id": 0, "title": 1, "year": 1 }
)

db.movies.explain("executionStats").find(
  { "year": { "$gt": 2010 } },
  { "_id": 0, "title": 1, "year": 1 }
)

db.listingsAndReviews.createIndex(
  {
    "name": "text",
    "summary": "text"
  },
  {
    "weights": {
      "name": 10,
      "summary": 5
    }
  }
)

db.listingsAndReviews.find(
  // 1. Filtre de recherche texte
  {
    "$text": { "$search": "beautiful cozy" }
  },
  // 2. Projection des champs √† afficher
  {
    "name": 1,
    "summary": 1,
    "_id": 0,
    "score": { "$meta": "textScore" }
  }
)
// 3. Tri par score de pertinence d√©croissant
.sort({
  "score": { "$meta": "textScore" }
})

################################

db.listingsAndReviews.aggregate([
  // √âtape 1 : Filtrer le plus t√¥t possible
  {
    "$match": { "address.market": "New York" }
  },
  // √âtape 2 : Trier le jeu de donn√©es r√©duit
  {
    "$sort": { "price": -1 }
  },
  // √âtape 3 : Limiter les r√©sultats
  {
    "$limit": 10
  },
  // √âtape 4 : Projeter uniquement les champs n√©cessaires
  {
    "$project": {
      "_id": 0,
      "name": 1,
      "price": 1,
      "address.market": 1
    }
  }
])

VS

db.listingsAndReviews.createIndex({
  "address.market": 1,
  "price": -1
})

---------------------

db.comments.aggregate([
  // √âtape 1 : Joindre avec la collection 'movies'
  {
    "$lookup": {
      "from": "movies",
      "localField": "movie_id",
      "foreignField": "_id",
      "as": "movie_details"
    }
  },
  // √âtape 2 : D√©construire le tableau pour un acc√®s facile
  {
    "$unwind": "$movie_details"
  },
  // √âtape 3 : Filtrer T√îT pour ne garder que les films r√©cents
  {
    "$match": { "movie_details.year": { "$gt": 2000 } }
  },
  // √âtape 4 : Grouper le jeu de donn√©es D√âJ√Ä filtr√© (beaucoup plus petit)
  {
    "$group": {
      "_id": "$movie_id",
      "title": { "$first": "$movie_details.title" }, // Garder le titre
      "commentCount": { "$sum": 1 }
    }
  },
  // √âtape 5 : Projeter le r√©sultat final
  {
    "$project": {
      "_id": 0,
      "title": 1,
      "commentCount": 1
    }
  }
])

VS

db.comments.aggregate([
    {
        "$lookup": {
            "from": "movies",
            "let": { "id": "$movie_id" },
            "pipeline": [
                // Filtre sur la collection 'movies' AVANT la jointure
                { "$match":
                    { "$expr":
                        { "$and":
                            [
                                { "$eq": [ "$_id",  "$$id" ] },
                                { "$gt": [ "$year", 2000 ] }
                            ]
                        }
                    }
                }
            ],
            "as": "movie_details"
        }
    },
    // On ne garde que les commentaires pour lesquels un film a √©t√© trouv√©
    {
        "$match": { "movie_details": { "$ne": [] } }
    },
    {
        "$group": {
            "_id": "$movie_id",
            "title": { "$first": { "$arrayElemAt": ["$movie_details.title", 0] } },
            "commentCount": { "$sum": 1 }
        }
    },
    {
        "$project": {
            "_id": 0,
            "title": 1,
            "commentCount": 1
        }
    }
])

###########################

Analyse du Probl√®me : Le "Hot Shard"
Utiliser un champ qui augmente de mani√®re monotone comme saleDate (ou l'_id par d√©faut) comme cl√© de sharding avec une strat√©gie par plage est une tr√®s mauvaise id√©e.

Le Probl√®me : Avec un sharding par plage, les donn√©es sont r√©parties en intervalles. Une cl√© comme saleDate garantit que toutes les nouvelles insertions (les ventes en temps r√©el) auront la valeur la plus √©lev√©e. Par cons√©quent, toutes ces nouvelles √©critures seront dirig√©es vers un seul et m√™me shard : celui qui contient la plage de dates la plus r√©cente.

Le "Hot Shard" : Ce ph√©nom√®ne est appel√© "hot shard" (ou shard chaud). Un shard devient "chaud" lorsqu'il re√ßoit une part disproportionn√©e du trafic. Pendant que ce shard est surcharg√©, les autres shards du cluster restent inactifs ou "froids", ne recevant aucune nouvelle √©criture.

Impact sur les Performances d'√âcriture
L'impact d'un "hot shard" est d√©sastreux pour les performances :

Goulot d'√©tranglement : Le shard chaud devient un goulot d'√©tranglement. La capacit√© d'√©criture de l'ensemble de votre cluster n'est plus la somme de tous vos shards, mais elle est limit√©e √† la capacit√© de ce seul shard surcharg√©.

Annulation des b√©n√©fices du sharding : L'objectif du sharding est de distribuer la charge. Avec un hot shard, vous avez la complexit√© d'une architecture distribu√©e sans en avoir les b√©n√©fices de performance.

Propositions de Solutions
Pour distribuer uniform√©ment les √©critures, voici deux approches bien plus efficaces.

1. Partitionnement par Hachage (Hashed Sharding)
Cette strat√©gie applique une fonction de hachage √† la valeur de la cl√©, ce qui garantit une distribution al√©atoire et uniforme des donn√©es √† travers les shards.

Champ √† utiliser : Le champ _id est un excellent candidat. Chaque _id est unique. En hachant cette valeur, vous vous assurez que deux ventes cons√©cutives seront tr√®s probablement √©crites sur des shards diff√©rents, r√©partissant ainsi la charge d'√©criture de mani√®re parfaitement √©quilibr√©e.

Commande : sh.shardCollection("supplies.sales", { "_id": "hashed" })

2. Partitionnement par Plages (Ranged Sharding) - Am√©lior√©
On peut toujours utiliser un sharding par plage, √† condition de choisir une cl√© compos√©e qui ne soit pas monotone.

Strat√©gie : On combine un champ √† haute cardinalit√© (qui a beaucoup de valeurs diff√©rentes, comme storeLocation ou customer.email) avec le champ monotone.

Cl√© propos√©e : { "storeLocation": 1, "saleDate": 1 }

Pourquoi c'est mieux ? Les √©critures seront d'abord distribu√©es entre les diff√©rents shards en fonction du magasin (storeLocation). Il n'y aura plus un seul "hot shard" pour toutes les ventes, mais plusieurs "points chauds" r√©partis sur le cluster, un pour chaque magasin actif. La charge est donc bien mieux distribu√©e.

----------------------------

Choix de la Cl√© de Sharding Id√©ale
Pour ce cas d'usage, la cl√© de sharding id√©ale est sans conteste le champ utilis√© dans la majorit√© des requ√™tes.

Cl√© de Sharding Id√©ale : { "address.country": 1 }

Justification : Le besoin principal de l'application est de rechercher des logements √† l'int√©rieur d'un m√™me pays. En choisissant address.country comme cl√©, vous vous assurez que tous les documents pour un pays donn√© (par exemple, "Spain") sont physiquement stock√©s ensemble sur le m√™me shard. Cela aligne parfaitement l'architecture physique des donn√©es avec le mod√®le d'acc√®s logique de l'application.

Avantages : √âviter les Requ√™tes "Scatter-Gather"
Le principal avantage de ce choix est l'optimisation des requ√™tes.

Quand une requ√™te comme db.listingsAndReviews.find({ "address.country": "Spain" }) est envoy√©e, le routeur de requ√™tes de MongoDB (mongos) consulte ses m√©tadonn√©es et sait exactement sur quel shard se trouvent les donn√©es pour l'Espagne.

Requ√™te Cibl√©e : La requ√™te est envoy√©e uniquement au shard pertinent.

√âvitement du "Scatter-Gather" : Le routeur n'a pas besoin de diffuser la requ√™te √† tous les shards du cluster pour ensuite rassembler les r√©sultats (ce qui est la d√©finition d'une requ√™te "scatter-gather").

Cela rend la grande majorit√© des recherches extr√™mement rapides et efficaces, car elles ne sollicitent qu'une petite partie du cluster.

Inconv√©nients Potentiels et Solutions
Le principal inconv√©nient de cette strat√©gie est le risque de d√©s√©quilibre des donn√©es, qui peut mener au ph√©nom√®ne de "hot shard".

Probl√®me : Si un pays, par exemple les √âtats-Unis, contient 10 fois plus de logements que n'importe quel autre pays, le shard h√©bergeant les donn√©es am√©ricaines deviendra un "hot shard". Il supportera beaucoup plus de stockage, de requ√™tes et de charge que les autres, annulant ainsi une partie des b√©n√©fices de la distribution de la charge.

Comment att√©nuer ce probl√®me ?
La meilleure fa√ßon de g√©rer ce risque est d'utiliser une cl√© de sharding compos√©e. On garde le pays comme premier crit√®re pour l'efficacit√© des requ√™tes, et on ajoute un deuxi√®me champ pour mieux distribuer les donn√©es √† l'int√©rieur d'un m√™me pays.

Solution Propos√©e : Cl√© Compos√©e avec Hachage

Nouvelle Cl√© : { "address.country": 1, "_id": "hashed" }

Fonctionnement :

Les donn√©es sont d'abord r√©parties par pays.

Ensuite, √† l'int√©rieur de chaque pays, les documents sont distribu√©s de mani√®re al√©atoire et uniforme en fonction du hachage de leur _id.

Avantage : Cela emp√™che un pays tr√®s populaire de cr√©er un unique "hot chunk" (un bloc de donn√©es massif). M√™me si toutes les donn√©es des √âtats-Unis sont sur le m√™me shard, elles seront r√©parties sur de nombreux chunks diff√©rents √† l'int√©rieur de ce shard, ce qui √©quilibre mieux la charge et facilite la migration de donn√©es si n√©cessaire.
